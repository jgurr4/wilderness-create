The design philosophy goes like this:

Design an app that uses java + vert.x + RxJava3 along with Neo4j and MySQL database on the backend, and React.JS + Vert.x on the frontend. Java needs to be able to communicate to the javascript frontend using Vert.x EventBus via the SockJS bridge. Every Verticle needs to be written using RxJava3 with zero blocking code except where absolutely necessary.

Feel free to fill in any gaps in this architecture I am describing below.

The backend architecture of the app is as follows:
Vert.x Verticles:
 - WildernessCreateVerticle: Contains the rxStart() method and starts up all the other Verticles in this app.
 - HttpsServerVerticle: Handles all connections to the wildernessCreate webpage which is hosted on port 8084. This verticle should be in charge of serving all static .js, .html or .css files to appear in anyone's browser. This verticle also routes most requests to other verticles as needed.
- UserVerticle: Handles creation, login, recovery, and deletion of user accounts from any eventBus requests routed to it by communicating to MariaDB verticle as needed to retrieve user details. It also creates the Session token and cookies as needed for any users that successfully login which is stored for 24 hours until it expires.
 - Neo4jVerticle: Handles all requests made to a backend Neo4j service that is running inside a local docker container on the server with port 8085. Allows all types of queries including reads, writes, deletes and more depending on the permissions of the user. Admin has ability to do anything, user can only read, but they can write and delete for their own custom made objects (I'll describe this feature more later)
 - HealthCheckVerticle: Handles a simple curl request that pings port '8084/health' to ask if the service is healthy, if the service is running then it should respond with a 'app is healthy' response body.
  - MariaDBVerticle: Handles all requests made to a backend MariaDB service that is running inside a local docker container on the server with port 8086. Allows all types of queries including reads, writes, deletes and more depending on the permissions of the user. Admin user has ability to do anything, but normal users will only be allowed certain abilities based on whatever makes sense. Probably MariaDB is used for user sensitive information like username, password, email, phone number etc...
- SmtpVerticle: This verticle is in charge of sending emails to users for password recovery. That's about it. User emails should be stored in MariaDB
 - Add any other Verticles that you think are required for this app.

The frontend architecture looks like this:
- At the top right there is a 'login', 'signup' and 'forgot password' buttons with two input fields next to them for 'username' and 'password'. When a user clicks on 'signup' it will take them to a new window with 3 input fields 'username', 'password', 'email' and a 'submit' button. The credentials they provide when they click 'submit' should be checked in backend MariaDBVerticle to be sure that username or email is not already in use by someone else. If username is in use it will ask the user to 'try another username as that is already taken', if email is in use it will say 'There is already an account with that email'. After successfully creating an account the user should be brought back to the main page fully logged in. If a user clicks on 'login' after filling the username and password field on the main page, then it should check to be sure that account exists, if not it will say 'failed login, please try again', if the user account does exist it will generate a session in the backend and hide the 'login', 'signup' buttons and the 'username' and 'password' input fields and replace them with a text saying 'welcome <username>'. Finally if a user clicks 'forgot password' it should open another window asking them to put in their email, and if the email exists in our MariaDB user database, then if their email is associated with a user account in our database, an email will be sent to them with a button in it called 'reset password' and when clicked it takes them to an endpoint of our URL which is hosted on port 8084/reset-password/<username>, based on whatever user account was associated with the email. This page will have a simple input field for 'new password', and a submit button. After they submit it the password will be updated for that user in our MariaDB database. If the email address provided is not associated with any user account, then the email we send to them will instead contain a 'no user was found associated with this email address. You may sign up to create an account here:' with a link to our login page endpoint.
 - Right in the center of the page, there should be a large Canvas, SVG or some other interactive HTML element which holds a interactive Technology Tree which gets all its data from neo4j database. The tech tree needs to allow users to click and drag the viewport, click on any node to see it's details in a small pop-up that has a 'x' to allow users to close it, or automatically closes when users click on a different node in the tech tree. And finally it needs to allow users to zoom in and out of the tech tree so they can see the full thing or just zoom in on individual nodes. Users can open some global tech trees by clicking on the 'tech trees' button which should appear centered above the tech tree, this will provide a list of default tech trees which I will design and users can view in their browser. As soon as they open more than one tech tree, the bar at the top of the tech tree element will divide into multiple tabs, Meaning there can be multiple tech trees opened at once up to a total of 5, and each one has a tab with it's filename and an 'x' inside it which if clicked will close that tab. If a user just clicks on the tab and not the 'x', then it will switch to viewing that tech tree in the viewport. An important feature of the tech tree is it should auto-generate branches and forked paths between nodes based on the 'relationships' defined in the neo4j database. This should be simple to do since neo4j already should handle that functionality for the most part. You just need to build the frontend code to render it.
 - Above the tech tree section there should be a button that when clicked on, generates a new tech tree based on the original vanilla one, but they get to name it whatever they want, and it allows them to edit the tech tree because it will pop up a new window overlay with the current neo4j file or a file that gets converted into neo4j script directly, so they can change and update individual entries that are generated into the tech tree, then they should be able to preview this and save it to their profile. If the user is not signed in when they try to create a custom tree, they will be given that option. If they refuse they will still be allowed to create the custom tree but it won't be possible for them to save it to our server, but they can download a png or pdf or svg image or some other image format which allows them to print it out or save it locally. They can also just print it directly using a print button. For users that are signed in, the tech tree they create will be automatically saved to either Neo4j or MariaDB database depending on whatever makes the most sense to you. Then whenever they login, their list of custom tech trees will appear for them. With a limit of 5 custom tech trees per person. If someone wants more they can save it locally and import it with an 'import' button that should appear beside the 'tech trees' button above the tech tree element.
- At the bottom of the screen if the user is signed in there will be a progress bar with the number of tech tree tasks completed by the user based on the current tech tree they are viewing.
- Below that, there should be a image pulled from whatever tech node/element comes next in the list for the current tech tree they are viewing.
- Below that there is a square green check-mark button, a square red 'x' button and when the green button is pressed a update is sent to neo4j to record that this particular task on this particular tech tree has been completed, when the red button a similar update is sent that records this tech was skipped. NOTE: Every skipped and completed task for a node in the tech tree should render as such inside the interactive tech tree section, probably by a red 'x' or a green 'check' in the node itself.
- Finally at the very bottom of the page is a table filled with all the possible tasks, along with a list of all the tech trees they are included in. They appear in no particular order. This data is pulled from Neo4j or MariaDB based on wherever it makes the most sense to store the full list of tech tasks.
- Add any other frontend logic or components you think are needed or make the most sense to fill in the gaps of my design.

I understand this is a complex task, if you feel confused about any part of this, or get stuck too long processing you can use more flexibility to adjust how things should be into what you think makes the most sense.









This app has to be able to work on many servers at the same time. So it will run completely inside docker containers.

Here is the tech stack for it:

visur instead of intellij for editor/ide
Kubernetes + docker containers/pods
Java + vertx + jerbil + rebul + observability bridge
MariaDB service in each pod for persistent data and user accounts
I think this app would not need Redis or etcd
frontend is not made until later. I suppose frontend will probably be react + redux + javascript + html + css + SVG or Canvas


Steps:
Step 1: Make Main verticle, and deploy all the required verticles for this app.

Step 2: Make all the required verticles, (with empty bodies) and create the Eventbus.

Step 3: Import jerbil, immutable collections and observability bridge.

Step 4: Build unit tests.

Step 5: Fill all the verticles with required code.




GOAL: I found another goal with my wildernessCreate app:
I want people to be able to survive as sustainably as possible and with as minimal accessories/tools as possible, and part of the requirement for sustainability is for people to have actual ability to progress through the use of internet, and since internet may not exist, people have to make their own internet, by having a hard drive filled with wikipedia articles and maps and other useful how-to articles to read. They will also need some interface for it that works, a e-ink display is one of the best possible options because out in the wild it takes the least amount of power and can stay on/charged for weeks before needing more power added to it. This is the way people can have access to the internet in the wild. Which is a invaluable resource people almost cannot live without anymore, because it has so much helpful information.  Furthermore if you want to make any progress technologically it can also save you so much time and energy and effort.

The problem with that is in order for it to be considered a sustainable concept, it needs to be able to be built by someone, so my goal is to continue the wilderness create app with a goal of being able to create a low powered display with a minimal OS and a large capacity storage device. Being able to reach that point in the tech tree is what will make it possible for people to repeatedly build and rebuild these types of devices so the knowledge of the internet can stay with us perpetually.


categories of nodes:
technique
task
tool
material

tasks always require technique and/or a source or tool
example task: grind wheat requires wheat, a grinding tool, and a grinding technique.
example task 2: filter clay from soil requires soil clay usually a clay filtering tool and a clay filtering technique
example task 3: obtain water requires a water source and a water retrieval technique.
example task without a source: count to 10. requires only technique since it is done in your head.

source: a place, person, or thing from which something comes or can be obtained.
resource: a stock or supply of assets that can be drawn upon by a person or system in order to function effectively.
In other words, a source is the origin where you can obtain things, and a resource is a store of that thing that you pull from as needed, both are finite, but one is much less finite than the other. Because I can chop wood for hundreds of millions of years before running out, but the amount I store in a shed for use later is dependant on how big my shed is and the amount that I decide to store.
I don't really like the word source in this context because it doesn't perfectly make sense, but it is the closest word I can think of, because at least it is more accurate than 'material', saying 'wheat material' just means wheat, but a 'wheat source' means either a origin of wheat. But that is not necessarily true either, you could have a source of wheat on a farm, but then after getting the wheat and storing it, your shed is not a source of wheat, but rather contains a resource of wheat. So instead of saying source/resource I'll just say source, and if a task does not involve the origin of a thing, then I'll leave out the word 'source' and just use the name of the material. You can be a source of a material, or you can be a store for resources. So when I say 'you need a source of iron for this task' that source could literally be anything including meteorites that fell down, or recycled tires, or chemically altered elements that turned into iron, literally anything. Actually nevermind, I think I won't use the word 'source' at all, because there is no need. I can just say you need a 'material' if someone needs to get a material from something, then I'll be more specific about the material they need. For example, for the task of 'obtaining clay' there is literally infinite number of ways you can obtain it, but what if I replaced it with 'filtering clay from soil' that is much more specific and makes more sense, because now there is no confusion about source vs resource etc... This is a task that you can complete in order to filter clay from soil in case you have lots of 'soil clay' which is a material of soil mixed with clay.
So it seems the path I provide people is totally option at all points, as it is meant to be. Just because you can obtain clay by filtering from soil, doesn't mean you have to, maybe you just find someone to source it from. But nevertheless, I'll provide the path and tasks for people to work on, and they can say 'skip' or 'done' to move on to the next task even if they did it an alternative way, I can provide useful alternatives, but I am not going to document all alternatives, that is too much information. So if I have a task that says 'obtain clay' there will be a number of paths the person can take to do so, but we cannot list all the ways and instructions for how to obtain clay, because there is infinite, I could walk down the street and forage for clay on the sidewalk, or I can buy some at a store. What I want to do is only show people the most universal and simple ways of obtaining clay without being dependent on others. So for the task of 'obtain clay' I would provide instructions that say 'complete the filter clay from soil task', but if I do that, I'll end up with multiple tasks for the same exact purpose, which is not useful and that is too much duplication. Instead I'll keep it simpler by saying 'obtain clay from soil' task as a pre-requisite for 'make a clay pot', and inside that task, I'll list the possible techniques, tools and sources for completing it, or maybe I'll just list the techniques and the techniques may list the tools and sources. because doing so will mean people can still choose to skip that task in case they found clay some other way.

So here is a example of that:
Task: make a clay pot 
 -> pre-requisite tasks: 
   - 'filter clay from soil'
   - 'find a source of water'

Task: filter clay from soil
 -> pre-requisite tasks:
   - 'create a 


alternative example: (I choose this method.
Task: make a clay pot 
  required materials:
    - clay
      Task: 'filter clay from soil'
    - water
      Task: 'find water source'
    - grog
      Task: 'filter sand from soil'
  Possible techniques: 
    - coil
    - puki

Material: clay
  Tasks:
    - filter clay from soil (Recommended)
    - locate termite mound
    - locate pure source of clay by rivers/streams/lakes

Task: filter clay from soil
  required materials: 
    - 'clay soil'
  Possible techniques:
    - levigation
    - soil smashing
    - sifting

Technique: sifting
  required tools:
    - sifter
      Task: 'make a clay sifter'
  required materials:
    - dry soil with loose clay
      Task: 'digging a hole'

Tool: sifter
  Tasks:
    - 'Make a clay sifter' (Recommended)
    - 'Make a wood sifter'

Task: digging a hole
  Possible tools:
    - digging stick (Recommended)
      Task: 'Make a digging stick'
    - digging rock
      Task: 'Make a digging rock'
    - shovel
      Task: 'Make a shovel'

As you see in the examples above, I list a task with various requirements in several categories, required tools, required materials, required techniques these make it possible to complete. The recommended task is the most universal one I can think of. Each task may have a list of required techniques, tools and materials, but techniques may also have a list of required tools and materials, and every tool and material also has a task for how to obtain them. This is the way it goes all the way back to the original sources of materials/tools. For example it will always be a task to obtain a material from the source, not a tool/material.

So there are only these possible relationships:
Task 		-Requires-> 	material
Task 		-Requires-> 	tool
Task 		-Requires-> 	technique
Source 		-obtained_by-> 	Task
Source 		-provides-> 	material
Material  	-obtained_by-> 	Task
Tool 		-obtained_by-> 	Task
Technique
(Might also have -ALT_REQUIRE->)

The root of everything is tasks that obtain sources and further tasks to use materials/tools/techniques made possible by those sources.

Here are all the unique possible labels for each type of node:
ALL:
  name: string
  source: string
  img: string
  (OPTIONAL) suited_for: string (could be homesteader, prepper, bugout, minimal, nomad, city, originator)  NOTE: I have to decide if I do this because there is lots of overlap.
Task:
  instructions: string
  recommended: boolean
Technique:
  instructions: string
  recommended: boolean
Source:
Material:
Tool:



As you see in the examples above, the techniques and sources are generic on purpose, that is because it is up to the user to decide what technique or resources to use depending on their circumstances/needs. For example task #3 there are many different sources of water, and many different techniques for retrieval. What I put in this guide are what I call 'recommended' techniques/resources, and 'alternatives'. The recommended techniques/resources are determined based on universality, effectiveness, efficiency, and simplicity but it may be changed often depending on if we learn more about alternative techniques. Which is highly encouraged especially if there is any process/technique/resource that is overly complex/difficult and ineficiant or not as universal as would be optimal.



I've got a new idea about nodes and their relationships. I'd be duplicating too many overlapping concepts if I made tools node, and techniques nodes etcd... so instead I'll do this:

Task -UNLOCKS-> Task
Task -ALTERNATIVE-> Task

Basically every task unlocks another task. Each task provides these labels:
 - instructions: String
 - source: URL with instructions/example
 - img: image for viewing

Examples:


Task: Make a bow drill
 instructions: Using the sharp stone or alt tech, carve a stick into a round point, then ...
 UNLOCKS: Make a fire
Task: Make a fire
 instructions: Using the bow drill blah...
 COMBINED_WITH: Make a charcoal fire pit
Task: Make a charcoal fire pit
 instructions: 'using a digging stick to dig a 4 foot deep and 4 feet wide hole'
 UNLOCKS: make a charcoal fire
Task: Make a digging stick
 instructions: Using the sharp stone or alt tech, carve a stick into a flat edge tip. 
 PARTIALLY_UNLOCKS: Make a charcoal fire pit
Task: Make charcoal
 instructions: Place wood on top of the fire pit, then use bow drill to create fire...
 COMBINED_WITH: forge


Alternatively:
Tech: bow drill
 obtaining: Using the sharp stone or alt tech, carve a stick into a round point, then ...
 UNLOCKS: fire
Tech: fire
 obtaining: Using the bow drill blah...
 COMBINED_WITH: digging stick
Tech: digging stick
 obtaining: Using the sharp stone or alt tech, carve a stick into a flat edge tip. 
 COMBINED_WITH: charcoal fire pit
Tech: charcoal fire pit
 obtaining: 'using a digging stick to dig a 4 foot deep and 4 feet wide hole'
 UNLOCKS: charcoal
Tech: charcoal
 obtaining: Place wood on top of the fire pit, then use bow drill to create fire...
 COMBINED_WITH: forge
Tech: forge
 obtaining: Use high clay content mud to ....
 COMBINED_WITH: iron bacteria
 COMBINED_WITH: iron sand
 COMBINED_WITH: iron ore
Material: iron sand
 obtaining: Search the wilderness and soil, use a panning method blah...
 UNLOCKS: iron
Source: water
 obtaining: 

Above seems like the simplest method, but there are still some flaws. How to handle multiple ways of obtaining something? Should there be multiple 'obtaining' dimensions? Like obtaining-1 obtaining-2 etc...? Or should we bring back techniques just for this purpose, or maybe something new called 'methods' 
Method -obtains-> Material/Tech/Source

There will be a Glossary of terms/Terminology page people can find link to in top of the page so they can understand terms like adobe brick etc...

Might add a 'definition' label to each tech.



There will be 'rabbit hole' nodes, which have a reference to a universal fundamentals guide for people to learn from in order to have all their bases covered and build off of in order to create advanced concepts on their own, or immediately understand more advanced concepts when introduced by others. (Memorization is bad)


aquireability levels:
- impossible
- lucky find
- unlikely
- possible
- likely
- universal

Explanation of each field in excel:
name			 
type			 -What type of node is it, (Might need to be removed from sheet unless I find out how to import this. If so I'll also have to split up the sheet into different sheets based on node-type, which would be pretty simple actually)
primary purpose		 -The reason you would want to obtain this thing.
recommended method	 -The method recommended for creating/obtaining this thing. Chosen based on universality, and stuff to learn.
substitute methods	 -Any methods that exist at this point when the tech is unlocked
acquirability		 -explaining how likely it is to find this in a 5 square kilometers of land.
aliases			 -Other names for this thing, common names, technical names etc...
image	      		 -Image for displaying in the UI.
references		 -Video url or online articles/wikipedia etc...


Each image will be generated by stable diffusion that I'll be running locally so I can have full control over the parameters to get the exact examples of what I want to show.
